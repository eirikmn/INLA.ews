#' Construct covariance matrix of time-dependent fGn model
#' 
#' This function constructs the covariance matrix of the fGn process under the 
#' assumption that the Hurst exponent changes over time. In the context of the 
#' \code{inla.ews} package this function is only used for simulating examples.
#' 
#' @param sigma Numeric of length 1. The innovation standard deviation
#' @param Hs Numeric of length corresponding to the length of the process. This gives 
#' the value of the Hurst exponent at each time point.
#' @return Returns the covariance matrix of the time dependent fGn process. This is 
#' a dense \code{matrix} object.
#' \code{object\$results}.
#' @examples 
#' n=50
#' Hs = seq(from=0.6,to=0.8,length.out=n)
#' sigma = 1
#' cov.matrix <- sigmaHmaker(sigma,Hs)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords covariance matrix fgn
#' @export
sigmaHmaker = function(sigma,Hs){
  n=length(Hs)
  H2 = 2*Hs
  k=0:(n-1)
  sigmat = matrix(NA,n,n)
  for(i in 1:n){
    for(j in 1:n){
      t = min(i,j)
      k=abs(i-j)
      sigmat[i,j] = sigma^2/2*( abs(k-1)^H2[t]-2*abs(k)^H2[t]+abs(k+1)^H2[t] )
    }
  }
  return(sigmat)
}

#' Simulate inferred forced response
#' 
#' This function employs Monte Carlo simulations to estimate the forced response from 
#' the fitted model.
#' 
#' @param object S3 object of type \code{inla.ews} which includes result from 
#' \code{inla}-program.
#' @param quick Boolean indicating whether or not the function should run without
#' storing simulations (faster, and less memory). If quantiles are desired this must
#' be set to \code{FALSE}.
#' @param seed Seed used for the random number generator.
#' @param intercept Intercept to shift the forced response to best fit the data. 
#' If \code{length(intercept)==1} it will be assumed to be fixed. If \code{length(intercept)>1} 
#' samples will be generated by assuming first value represents mean and second value 
#' represents standard deviation. 
#' @param print.progress boolean indicating if progress should be printed to screen.
#' @return Returns the same S3 object of class \code{inla.ews} as included in the 
#' input arguments, but appends summary statistics \code{object\$forced}.
#' 
#' @examples 
#' \donttest{
#' n = 200
#' time=1:n
#' a = 0.6
#' b = 0.35/n
#' Hs = a+b*time
#' F0 = -3
#' sigmaf=0.1
#' sigma = 1.2
#' 
#' s = fgn_timedep_sim(n,Hs=Hs)
#' forcing = arima.sim(model=list(ar=c(0.95)),n=n,sd=sqrt(1-0.95^2))+1:n/n*7
#' muvek = mu.computer(forcing,sigmaf,F0,memory=Hs,model="fgn")
#' data = s + muvek
#' object = inla.ews(data,forcing,model="fgn",memory.true=Hs)
#' 
#' object = forcingmaker(object,quick=FALSE,print.progress=TRUE,
#'                     intercept=object$.args$intercept)
#' summary(object)
#' plot(object)
#' }
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}, \link{mu.computer}}
#' @keywords forcing response mean 
#' @export
#' @importFrom stats rnorm
forcingmaker <- function(object,quick=FALSE,seed=1234,intercept=0,
                       print.progress=FALSE){
  time.start = Sys.time()
  if(print.progress){
    cat("Initiating sampling procedure to infer forced component of the response.\n",sep="")
  }
  model=object$.args$model
  set.seed(seed)
  if(length(object$.args$forcing)==0){
    warning("'Forcing' argument not found. Skipping this step.")
    return(object)
  }
  if(model %in% c("fgn","lrd")){
    nsamples = ncol(object$results$simulations$H_sims)
  }else if(model %in% c("ar1","ar(1)","1")){
    nsamples = ncol(object$results$simulations$phi_sims)
  }
  # if(intercept==0 && object$.args$intercept){
  #   intercept = object$.args$intercept
  # }
  
  if(print.progress){
    cat("Starting mu Monte Carlo sampling with n = ",format(nsamples,scientific=F)," simulations..\n",sep="")
  }
  #We sample intercepts. We know this is Gaussian since we use Gaussian priors
  if(length(intercept)>1){
    interceptsims = rnorm(nsamples,as.numeric(intercept[1]),as.numeric(intercept[2])) 
  }else if(length(intercept)==1){
    interceptsims = rep(intercept,nsamples)
  }
  
                               
  n=nrow(object$.args$inladata)
  hypersamples = INLA::inla.hyperpar.sample(nsamples,object$inlafit)
  
  sigmaf_samples = 1/sqrt(exp(hypersamples[,4]))
  F0_samples = hypersamples[,5]
  
  if(model %in% c("fgn","lrd")){
    memorysamples = object$results$simulations$H_sims
  }else if(model %in% c("ar1","ar(1)","1")){
    memorysamples = object$results$simulations$phi_sims
  }
  
  forcing = object$.args$forcing
  if(!quick){
    meanmat = matrix(NA,n,nsamples)
  }
  xsumvec = 0
  x2sumvec = 0
  for(iter in 1:nsamples){
    if(print.progress){
      if(iter %% 5000 == 0) cat("Sampling mean vector ",iter,"/",nsamples,"\n",sep="")
    }
    muvek = numeric(n)
    zz = sigmaf_samples[iter]*(F0_samples[iter]+forcing)
    if(tolower(model) %in% c("ar1","ar(1)","1")){
      compute_mu_ar1(muvek, n, zz, memorysamples[,iter])
    }else if(tolower(model) %in% c("fgn","lrd")){
      compute_mu_ar1(muvek, n, zz, memorysamples[,iter])
    }
    
    if(!quick){
      meanmat[,iter]=muvek
    }
    xsumvec = xsumvec + muvek
    x2sumvec = x2sumvec + muvek^2
    
  }
  
  if(print.progress){
    cat("Completed sampling!\n",sep="")
  }
  
  mu.mean = as.numeric(xsumvec/nsamples) + mean(interceptsims)
  mu.sd=as.numeric(sqrt( 1/(nsamples-1)*( 
    x2sumvec -2*mu.mean*xsumvec + nsamples*mu.mean^2 ) ))
  
  meanmat = sweep(meanmat,2,interceptsims,"+") #add intercept to forced responses
  
  object$forced = list(mean = mu.mean, sd = mu.sd)
  
  if(!quick){
    if(print.progress){
      cat("Computing quantiles","...",sep="")
    }
    mu.quant0.025 = numeric(n)
    mu.quant0.25 = numeric(n)
    mu.quant0.5 = numeric(n)
    mu.quant0.75 = numeric(n)
    mu.quant0.975 = numeric(n)
    for(iter in 1:n){
      dens = density(meanmat[iter,])
      mu.quant0.025[iter]=INLA::inla.qmarginal(0.025,dens)
      mu.quant0.25[iter]=INLA::inla.qmarginal(0.25,dens)
      mu.quant0.5[iter]=INLA::inla.qmarginal(0.5,dens)
      mu.quant0.75[iter]=INLA::inla.qmarginal(0.75,dens)
      mu.quant0.975[iter]=INLA::inla.qmarginal(0.975,dens)
    }
    object$forced$quant0.025 = mu.quant0.025
    object$forced$quant0.25 = mu.quant0.25
    object$forced$quant0.5 = mu.quant0.5
    object$forced$quant0.75 = mu.quant0.75
    object$forced$quant0.975 = mu.quant0.975
    if(print.progress){
      cat(" completed!\n",sep="")
    }
  }
  
  time.total = difftime(Sys.time(), time.start,units="secs")[[1]]
 
  object$cpu.used$meansim = time.total
  
return(object)
  
}

#' Computes the forced response
#' 
#' This function computes the forced response given known forcing and memory development.
#' 
#' @param forcing Known forcing.
#' @param sigmaf Scaling parameter of forcing.
#' @param F0 Shift parameter of forcing.
#' @param a Intercept of memory evolution.
#' @param b Slope of memory evolution.
#' @param memory If memory is to be given explicitly this is done here as \code{numeric} object.
#' @param model Character string describing which model is assumed for the noise. 
#' Can be \code{"ar1"} (default) or \code{"fgn"}.
#' @return Returns the forced response based on the input arguments.
#' 
#' @examples 
#' n = 300
#' F0 = -1
#' sigmaf = 0.2
#' a = 0.6
#' b = 0.3/n
#' time = 1:n
#' Hs = a+b*time
#' forcing = arima.sim(model=list(ar=c(0.95)),n=n,sd=sqrt(1-0.95^2))+1:n/n*0.2
#' zz = sigmaf*(F0+forcing)
#' 
#' muvek = mu.computer(forcing,sigmaf,F0,memory=Hs,model="fgn")
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}, \link{forcingmaker}}
#' @keywords forcing response mean
#' @export 
#' @importFrom Matrix sparseMatrix
mu.computer <- function(forcing,sigmaf,F0,a=0.6,b=0.2,memory=NULL,model="ar1"){
  n <- length(forcing)
  if(is.null(memory)){
    memory = a+b*seq(0,1,length.out=n)
  }
  

  zz = as.numeric(sigmaf*(F0+forcing))
  if(tolower(model) %in% c("ar1","ar(1)","1")){
    lambdas = memory-1
    if(TRUE){
      start0=Sys.time()
      
      mu = numeric(n)
      compute_mu_ar1(mu, n, zz,  memory)
      # 
      # xx = exp(lambdas[ii]*(ii-jj+0.5))
      # G = sparseMatrix(i=ii,j=jj,x=xx,symmetric=FALSE)
      # mu = G%*%zz
      time0 = Sys.time()-start0
    }else{
      start1=Sys.time()
      mu=numeric(n)
      for(i in 1:n){
        mu[i] = exp(lambdas[i]*(i-1:i+0.5))%*%zz[1:i]
      }
      time1 = Sys.time()-start1
    }
  }else if(tolower(model) %in% c("fgn","lrd")){
    if(TRUE){
      mu = numeric(n)
      compute_mu_fgn(mu, n, zz,  memory)
      # xx = (ii-jj+0.5)^(memory[ii]-3/2)
      # G = sparseMatrix(i=ii,j=jj,x=xx,symmetric=FALSE)
      # mu = G%*%zz
    }else{
      mu=numeric(n)
      for(i in 1:n){
        mu[i] = (i-1:i+0.5)^(memory[i]-3/2)%*%zz[1:i]
      }
    }
  }
  return(as.numeric(mu))
}


#' Simulate time dependent AR(1) series
#' 
#' This function produces samples from a given time dependent AR(1) process.
#' 
#' @param n The length of the simulated time series.
#' @param sigma The standard deviation of the innovations.
#' @param a Intercept in the evolution of the lag-one correlation.
#' @param b Slope in the evolution of the lag-one correlation.
#' @param phis Numeric of length \code{n}. If evolution of lag-one correlation is 
#' to be given explicitly this is done here. Overrides \code{a} and \code{b}.
#' @return Returns the simulated time series as a \code{numeric} object.
#' 
#' @examples 
#' n = 200
#' sims = ar1_timedep_sim(n,sigma=1,a=0.2,b=0.7)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation ar1 timedep 
#' @export
#' @importFrom stats rnorm
ar1_timedep_sim <- function(n,sigma=1,a=0.2,b=0.7,phis=NULL){
  if(is.null(phis)){
    phis = a+b*seq(0,1,length.out=n)
  }
  noise=numeric(n)
  noise[1] = rnorm(1,mean=0,sd=sigma)
  for(i in 2:n){
    noise[i] = rnorm(1, mean=phis[i]*noise[i-1],sd=sigma)
  }
  return(as.numeric(noise))
}
#' Simulate time dependent fGn series
#' 
#' This function produces samples from a given time dependent fractional Gaussian noise process.
#' 
#' @param n The length of the simulated time series..
#' @param sigma The standard deviation of the innovations.
#' @param a Intercept in the evolution of the Hurst exponent.
#' @param b Slope in the evolution of the Hurst exponent.
#' @param Hs Numeric of length \code{n}. If evolution of Hurst exponent is 
#' to be given explicitly this is done here. Overrides \code{a} and \code{b}.
#' @return Returns the simulated time series as a \code{numeric} object.
#' 
#' @examples 
#' n = 200
#' sims = fgn_timedep_sim(n,sigma=1,a=0.2,b=0.7)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation ar1 timedep 
#' @export
#' @importFrom stats rnorm
fgn_timedep_sim <- function(n,sigma=1,a=0.6,b=0.3,Hs=NULL){
  if(is.null(Hs)){
    Hs = a+b*seq(0,1,length.out=n)
  }
  sigmat = sigmaHmaker(sigma,Hs)
  sigmachol = chol(sigmat)
  noise = sigmachol%*%rnorm(n)
  return(noise)
}



