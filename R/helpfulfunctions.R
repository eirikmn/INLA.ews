#' Construct covariance matrix of time-dependent fGn model
#' 
#' This function constructs the covariance matrix of the fGn process under the 
#' assumption that the Hurst exponent changes over time. In the context of the 
#' \code{inla.ews} package this function is only used for simulating examples.
#' 
#' @param sigma Numeric of length 1. The innovation standard deviation
#' @param a Numeric of length 1. Intercept of the memory parameter
#' @param b Numeric of length 1. Slope of the memory parameter
#' @param n Integer. Length of the simulation.
#' @return Returns the covariance matrix of the time dependent fGn process. This is 
#' a dense \code{matrix} object.
#' \code{object\$results}.
#' @examples 
#' n=50
#' a=0.6
#' b=0.2
#' sigma = 1
#' cov.matrix <- sigmaHmaker(sigma,a,b,n)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords covariance matrix fgn
#' @export
sigmaHmaker = function(sigma,a,b,n){
  
  k=0:(n-1)
   sigmat = matrix(NA,n,n)
  
  for(t in 1:n){
    for(s in 1:n){
      sigmat[i,j] = fgncor(a,b,n,t,s)
    }
  }
  sigmat = sigma^2*sigmat
  return(sigmat)
}


#' Construct covariance matrix of time-dependent ar1g model
#' 
#' This function constructs the covariance matrix of the ar1g process under the 
#' assumption that the Hurst exponent changes over time. In the context of the 
#' \code{inla.ews} package this function is only used for simulating examples.
#' 
#' @param sigma Numeric of length 1. The innovation standard deviation
#' @param a Numeric of length 1. Intercept of the memory parameter
#' @param b Numeric of length 1. Slope of the memory parameter
#' @param n Integer. Length of the simulation.
#' @return Returns the covariance matrix of the time dependent fGn process. This is 
#' a dense \code{matrix} object.
#' \code{object\$results}.
#' @examples 
#' n=50
#' a=0.6
#' b=0.2
#' sigma = 1
#' cov.matrix <- sigmaar1maker(sigma,a,b,n)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords covariance matrix fgn
#' @export
sigmaar1maker = function(sigma,a,b,n){
  # n=length(Hs)
  #H2 = 2*Hs
  k=0:(n-1)
  # sigmat = matrix(NA,n,n)
  # for(i in 1:n){
  #   for(j in 1:n){
  #     t = min(i,j)
  #     #t = (i+j)/2
  #     k=abs(i-j)
  #     H2 = 2*(a+b*t/n)
  #     #sigmat[i,j] = sigma^2/2*( abs(k-1)^H2[t]-2*abs(k)^H2[t]+abs(k+1)^H2[t] )
  #     sigmat[i,j] = sigma^2/2*( abs(k-1)^H2-2*abs(k)^H2+abs(k+1)^H2 )
  #   }
  # }
  
  
  Gmat = matrix(NA,n,n)
  for(i in 1:n){
    for(j in 1:n){
      Gmat[i,j] = greensar1(i,j,a,b,n)
    }
  }
  covmat = sigma^2*Gmat%*%t(Gmat)
  chol(covmat)
  return(covmat)
}



#' Compute Green's function for time-dependent fGn model
#' 
#' This function computes Green's function.
#' 
#' @param t Row index in the Green's matrix.
#' @param s Column index in the Green's matrix.
#' @param a Intercept in lienar function for Hurst exponent.
#' @param b Slope in lienar function for Hurst exponent.
#' @param n Number of data points (used for rescaling \code{b}).
#' @return Returns the evaluation of the Green's function at \code{(t-s)}.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{sigmaHmaker}}
#' @keywords Greens function Hurst exponent 
greensH = function(t,s,a,b,n){
  if(t-s<0){
    return(0)
  }else{
    H = a+b*max(t,s)/n
    ret = (t-s+0.5)^(H-3/2)
    return(ret)
  }
}


#' Compute Green's function for time-dependent AR(1) model
#' 
#' This function computes Green's function.
#' 
#' @param t Row index in the Green's matrix.
#' @param s Column index in the Green's matrix.
#' @param a Intercept in lienar function for Hurst exponent.
#' @param b Slope in lienar function for Hurst exponent.
#' @param n Number of data points (used for rescaling \code{b}).
#' @return Returns the evaluation of the Green's function at \code{(t-s)}.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{sigmaar1maker}}
#' @keywords Greens function Hurst exponent 
greensar1 = function(t,s,a,b,n){
  if(t-s<0){
    return(0)
  }else{
    # phi = a+b*max(t,s)/n
    # phi = a+b*(t+s)/2/n
    phi = a+b*min(t,s)/n
    # ret = (t-s+0.5)^(H-3/2)
    
    ret = phi^(t-s)
    return(ret)
  }
}



#' Simulate inferred forced response
#' 
#' This function employs Monte Carlo simulations to estimate the forced response from 
#' the fitted model.
#' 
#' @param object S3 object of type \code{inla.ews} which includes result from 
#' \code{inla}-program.
#' @param quick Boolean indicating whether or not the function should run without
#' storing simulations (faster, and less memory). If quantiles are desired this must
#' be set to \code{FALSE}.
#' @param seed Seed used for the random number generator.
#' @param intercept Intercept to shift the forced response to best fit the data. 
#' If \code{length(intercept)==1} it will be assumed to be fixed. If \code{length(intercept)>1} 
#' samples will be generated by assuming first value represents mean and second value 
#' represents standard deviation. 
#' @param print.progress boolean indicating if progress should be printed to screen.
#' @return Returns the same S3 object of class \code{inla.ews} as included in the 
#' input arguments, but appends summary statistics \code{object\$forced}.
#' 
#' @examples 
#' \donttest{
#' set.seed(123)
#' n = 300
#' time=1:n
#' a = 0.5
#' b = 0.35/n
#' phis = a+b*time
#' F0 = -3
#' sigmaf=0.7
#' sigma = 1.2
#' 
#' s = ar1_timedep_sim(n,phis=phis)
#' forcing = arima.sim(model=list(ar=c(0.95)),n=n,sd=sqrt(1-0.95^2))+1:n/n*5
#' muvek = mu.computer(forcing,sigmaf,F0,memory=phis,model="ar1")
#' data = s + muvek
#' object = inla.ews(data,forcing,model="ar1",memory.true=phis)
#' 
#' object = forcingmaker(object,quick=FALSE,print.progress=TRUE,
#'                     intercept=object$.args$intercept)
#' summary(object)
#' plot(object)
#' 
#' 
#' }
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}, \link{mu.computer}}
#' @keywords forcing response mean 
#' @export
#' @importFrom stats rnorm
forcingmaker <- function(object,quick=FALSE,seed=1234,intercept=0,
                       print.progress=FALSE){
  time.start = Sys.time()
  if(print.progress){
    cat("Initiating sampling procedure to infer forced component of the response.\n",sep="")
  }
  model=object$.args$model
  set.seed(seed)
  if(length(object$.args$forcing)==0){
    warning("'Forcing' argument not found. Skipping this step.")
    return(object)
  }
  if(model %in% c("fgn","lrd")){
    nsamples = ncol(object$results$simulations$H_sims)
  }else if(model %in% c("ar1","ar(1)","1")){
    nsamples = ncol(object$results$simulations$phi_sims)
  }
  # if(intercept==0 && object$.args$intercept){
  #   intercept = object$.args$intercept
  # }
  
  if(print.progress){
    cat("Starting mu Monte Carlo sampling with n = ",format(nsamples,scientific=F)," simulations..\n",sep="")
  }
  #We sample intercepts. We know this is Gaussian since we use Gaussian priors
  if(length(intercept)>1){
    interceptsims = rnorm(nsamples,as.numeric(intercept[1]),as.numeric(intercept[2])) 
  }else if(length(intercept)==1){
    interceptsims = rep(intercept,nsamples)
  }
  
                               
  n=nrow(object$.args$inladata)
  hypersamples = INLA::inla.hyperpar.sample(nsamples,object$inlafit)
  
  sigmaf_samples = 1/sqrt(exp(hypersamples[,4]))
  F0_samples = hypersamples[,5]
  
  if(model %in% c("fgn","lrd")){
    memorysamples = object$results$simulations$H_sims
  }else if(model %in% c("ar1","ar(1)","1")){
    memorysamples = object$results$simulations$phi_sims
  }
  
  forcing = object$.args$forcing
  if(!quick){
    meanmat = matrix(NA,n,nsamples)
  }
  xsumvec = 0
  x2sumvec = 0
  for(iter in 1:nsamples){
    if(print.progress){
      if(iter %% 5000 == 0) cat("Sampling mean vector ",iter,"/",nsamples,"\n",sep="")
    }
    muvek = numeric(n)
    zz = sigmaf_samples[iter]*(F0_samples[iter]+forcing)
    
    muvek = mu.computer(forcing,sigmaf=sigmaf_samples[iter],
                        F0=F0_samples[iter],
                        memory=memorysamples[,iter],
                        model=model)
    # if(tolower(model) %in% c("ar1","ar(1)","1")){
    #   compute_mu_ar1(muvek, n, zz, memorysamples[,iter])
    # }else if(tolower(model) %in% c("fgn","lrd")){
    #   compute_mu_fgn(muvek, n, zz, memorysamples[,iter])
    # }
    
    if(!quick){
      meanmat[,iter]=muvek
    }
    xsumvec = xsumvec + muvek
    x2sumvec = x2sumvec + muvek^2
    
  }
  
  if(print.progress){
    cat("Completed sampling!\n",sep="")
  }
  
  mu.mean = as.numeric(xsumvec/nsamples) + mean(interceptsims)
  mu.sd=as.numeric(sqrt( 1/(nsamples-1)*( 
    x2sumvec -2*mu.mean*xsumvec + nsamples*mu.mean^2 ) ))
  
  meanmat = sweep(meanmat,2,interceptsims,"+") #add intercept to forced responses
  
  object$forced = list(mean = mu.mean, sd = mu.sd)
  
  if(!quick){
    if(print.progress){
      cat("Computing quantiles","...",sep="")
    }
    mu.quant0.025 = numeric(n)
    mu.quant0.25 = numeric(n)
    mu.quant0.5 = numeric(n)
    mu.quant0.75 = numeric(n)
    mu.quant0.975 = numeric(n)
    for(iter in 1:n){
      dens = density(meanmat[iter,])
      mu.quant0.025[iter]=INLA::inla.qmarginal(0.025,dens)
      mu.quant0.25[iter]=INLA::inla.qmarginal(0.25,dens)
      mu.quant0.5[iter]=INLA::inla.qmarginal(0.5,dens)
      mu.quant0.75[iter]=INLA::inla.qmarginal(0.75,dens)
      mu.quant0.975[iter]=INLA::inla.qmarginal(0.975,dens)
    }
    object$forced$quant0.025 = mu.quant0.025
    object$forced$quant0.25 = mu.quant0.25
    object$forced$quant0.5 = mu.quant0.5
    object$forced$quant0.75 = mu.quant0.75
    object$forced$quant0.975 = mu.quant0.975
    if(print.progress){
      cat(" completed!\n",sep="")
    }
  }
  
  time.total = difftime(Sys.time(), time.start,units="secs")[[1]]
 
  object$cpu.used$meansim = time.total
  
return(object)
  
}



#' Computes the forced response
#' 
#' This function computes the forced response given known forcing and memory development.
#' 
#' @param forcing Known forcing.
#' @param sigmaf Scaling parameter of forcing.
#' @param F0 Shift parameter of forcing.
#' @param a Intercept of memory evolution.
#' @param b Slope of memory evolution.
#' @param memory If memory is to be given explicitly this is done here as \code{numeric} object.
#' @param model Character string describing which model is assumed for the noise. 
#' Can be \code{"ar1"} (default) or \code{"fgn"}.
#' @return Returns the forced response based on the input arguments.
#' 
#' @examples 
#' n = 300
#' F0 = -1
#' sigmaf = 0.2
#' a = 0.6
#' b = 0.3/n
#' time = 1:n
#' Hs = a+b*time
#' forcing = arima.sim(model=list(ar=c(0.95)),n=n,sd=sqrt(1-0.95^2))+1:n/n*0.2
#' zz = sigmaf*(F0+forcing)
#' 
#' muvek = mu.computer(forcing,sigmaf,F0,memory=Hs,model="fgn")
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}, \link{forcingmaker}}
#' @keywords forcing response mean
#' @export 
#' @importFrom Matrix sparseMatrix
mu.computer <- function(forcing,sigmaf,F0,a=0.6,b=0.2,memory=NULL,model="ar1"){
  n <- length(forcing)
  if(is.null(memory)){
    memory = a+b*seq(0,1,length.out=n)
  }
  

  zz = as.numeric(sigmaf*(F0+forcing))
  if(tolower(model) %in% c("ar1","ar(1)","1")){
    lambdas = memory-1
    if(FALSE){
      start0=Sys.time()
      
      mu = numeric(n)
      # compute_mu_ar1(mu, n, zz,  memory)
      # 
      # xx = exp(lambdas[ii]*(ii-jj+0.5))
      # G = sparseMatrix(i=ii,j=jj,x=xx,symmetric=FALSE)
      # mu = G%*%zz
      time0 = Sys.time()-start0
    }else{
      start1=Sys.time()
      mu=numeric(n)
      for(i in 1:n){
        mu[i] = exp(lambdas[i]*(i-1:i+0.5))%*%zz[1:i]
      }
      time1 = Sys.time()-start1
    }
  }else if(tolower(model) %in% c("fgn","lrd")){
    if(FALSE){
      mu = numeric(n)
      # compute_mu_fgn(mu, n, zz,  memory)
      # xx = (ii-jj+0.5)^(memory[ii]-3/2)
      # G = sparseMatrix(i=ii,j=jj,x=xx,symmetric=FALSE)
      # mu = G%*%zz
    }else{
      mu=numeric(n)
      for(i in 1:n){
        mu[i] = (i-1:i+0.5)^(memory[i]-3/2)%*%zz[1:i]
      }
    }
  }
  return(as.numeric(mu))
}


#' Simulate time dependent AR(1) series
#' 
#' This function produces samples from a given time dependent AR(1) process.
#' 
#' @param n The length of the simulated time series.
#' @param sigma The standard deviation of the innovations.
#' @param a Intercept in the evolution of the lag-one correlation.
#' @param b Slope in the evolution of the lag-one correlation.
#' @param phis Numeric of length \code{n}. If evolution of lag-one correlation is 
#' to be given explicitly this is done here. Overrides \code{a} and \code{b}.
#' @return Returns the simulated time series as a \code{numeric} object.
#' 
#' @examples 
#' n = 200
#' sims = ar1_timedep_sim(n,sigma=1,a=0.2,b=0.7)
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation ar1 timedep 
#' @export
#' @importFrom stats rnorm
ar1_timedep_sim <- function(n,sigma=1,a=0.2,b=0.7,phis=NULL){
  if(is.null(phis)){
    phis = a+b*seq(0,1,length.out=n)
  }
  noise=numeric(n)
  noise[1] = rnorm(1,mean=0,sd=sigma)
  for(i in 2:n){
    noise[i] = rnorm(1, mean=phis[i]*noise[i-1],sd=sigma)
  }
  return(as.numeric(noise))
}

#' Simulate time dependent AR(1) series (using Green's function)
#' 
#' This function produces samples from a given time dependent AR(1) process using Green's function instead of AR(1) directly.
#' 
#' @param n The length of the simulated time series.
#' @param sigma The standard deviation of the innovations.
#' @param a Intercept in the evolution of the lag-one correlation.
#' @param b Slope in the evolution of the lag-one correlation.
#' @param phis Numeric of length \code{n}. If evolution of lag-one correlation is 
#' to be given explicitly this is done here. Overrides \code{a} and \code{b}.
#' @return Returns the simulated time series as a \code{numeric} object.
#' 
#' @examples 
#' \donttest{
#' n = 600
#' a=0.5
#' b=-0.1
#' phis = seq(from=a,to=a+b,length.out=n)
#' sims = ar1g_timedep_sim(n,sigma=1,a=a,b=b)
#' }
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation ar1 timedep 
#' @export
#' @importFrom stats rnorm
ar1g_timedep_sim <- function(n,sigma=1,a=0.2,b=0.7,phis=NULL){
  if(is.null(phis)){
    phis = a+b*seq(0,1,length.out=n)
  }
  lambdas = -log(phis)
  
  noise=numeric(n)
  sigma1 = sigma^2/(2*lambdas[1])
  noise[1] = rnorm(1,mean=0,sd=sigma1)
  for(i in 2:n){
    sigmaeps = sigma^2/2*( 1/lambdas[i] - phis[i]^2/lambdas[i-1] )
    noise[i] = rnorm(1, mean=phis[i]*noise[i-1],sd=sigmaeps)
  }

    # kappas = numeric(nn)
  # 
  # kappas[1] = 2*lambdas[1]/sx^2
  # kappas[2:nn] = 1/sx^2*1/( 1/(2*lambdas[2:nn])-phis[2:nn]^2/(2*lambdas[1:(nn-1)]) )
  # 
  # ii = c(1:nn,2:nn) ; jj = c(1:nn,1:(nn-1))
  # xx = c(kappas[1:(nn-1)]+phis[2:nn]^2*kappas[2:nn],kappas[nn],
  #        -phis[2:nn]*kappas[2:nn])
  # Q = Matrix::sparseMatrix(i=ii,j=jj,x=xx,symmetric=TRUE)
  # covmat = solve(Q)
  # noise = chol(covmat)%*%rnorm(n)
   return(as.numeric(noise))
}


#' Hypergeometric function
#' 
#' The hypergeometric function 2F1(a,b;c;z).
#' 
#' @param a First parameter.
#' @param b Second parameter.
#' @param c Third parameter.
#' @param z Fourth parameter.
#' @param trunc The number of terms used before truncating the infinite series.
#' @return Returns the hypergeometric function evaluated using parameters \code{a,b,c} and \code{z}.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep 
hyperg2F1 = function(a,b,c,z,trunc=300){
  kk = 0:(trunc-1)
  cp = cumprod((a+kk)*(b+kk)/(c+kk)*z/(1:trunc)  ) 
  s = 1 + sum(cp)
  return(s)
}

#' Incomplete beta function
#' 
#' The incomplete beta function (allows for some negative parameters).
#' 
#' @param a First parameter.
#' @param b Second parameter.
#' @param z The upper bound of the integral of the ordinary beta function.
#' @param trunc The number of terms used before truncating the infinite series.
#' @return Returns the value of the incomplete beta function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep 
incBeta = function(z,a,b,trunc){
  hg = 1/a*z^a*hyperg(a,1-b,1+a,z,trunc=trunc)
  return(hg)
}

#' Adapted gamma function
#' 
#' A version of the gamma function used in other functions.
#' 
#' @param a First parameter.
#' @param b Second parameter.
#' @param n Length of process.
#' @param t First index.
#' @param s Second index.
#' @return Returns the value of the function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep 
gammas = function(a,b,n,t,s){
  if((b *(s + t - 2 *max(s, t)))/n==0){
    return(0)
  }
  else{
    return( ( gamma(-1 + 2*a+(b*(s + t))/n)*
              gamma(1 - 2*a-(2*b*max(s,t))/n))/
              gamma((b*(s + t - 2*max(s, t)))/n) 
            )
  }
}


#' Time dependent constant 
#' 
#' Necessary for computing covariance function of time-varying fGn
#' 
#' @param H Hurst exponent
#' @return Returns the value of the function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep 
ch = function(H){
  return(sqrt( H*(2*H-1)/(beta(2-2*H, H-0.5)) ))
}

#' Product of time dependent constant 
#' 
#' Necessary for computing covariance function of time-varying fGn
#' 
#' @param Ht First Hurst exponent
#' @param Hs Second Hurst exponent
#' @return Returns the value of the function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep
cts = function(Ht,Hs){
  return(ch(Ht)*ch(Hs))
}

#' Beta1 computation
#' 
#' Necessary for computing covariance function of time-varying fGn
#' 
#' @param Ht First Hurst exponent
#' @param Hs Second Hurst exponent
#' @return Returns the value of the function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep
beta1 = function(Ht,Hs){
  return(beta(Ht-0.5, 2-Ht-Hs))
}

#' Beta1 computation
#' 
#' Necessary for computing covariance function of time-varying fGn
#' 
#' @param Ht First Hurst exponent
#' @param Hs Second Hurst exponent
#' @return Returns the value of the function.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fgn timedep
beta2 = function(Ht,Hs){
  return(beta(Ht-Hs+1, Ht+Hs-1))
}


#' Correlation of time-dependent fractional Brownian motion
#' 
#' Correlation of fractional Brownian motion with time-dependent increments.
#' 
#' @param a Starting point of Hurst exponent (intercept).
#' @param b Slope of Hurst exponent.
#' @param n Length of process.
#' @param t First index.
#' @param s Second index.
#' @return Returns the correlation between indices 't' and 's' of the time-dependent fBm.
#' 
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation fbm timedep 
fgncor = function(a,b,n,t,s){
  HH = seq(from=a,to=a+b,length.out=n)
  Ht = HH[t]
  Hs = HH[s]
  
  return( cts(Ht,Hs)/(Ht+Hs) * ( beta1(Ht,Hs)*beta2(Ht,Hs)*s^(Ht+Hs) +
                                   beta1(Hs,Ht)*beta2(Hs,Ht)*t^(Ht+Hs) +
                                   beta1(Hs,Ht)*t*(t-s)^(Ht+Hs-1)/(Ht+Hs-1)*(t/s)^(Ht-Hs) *
                                   (hyperg2F1(1,2*Ht,Hs+Ht,(s-t)/s) -
                                      hyperg2F1(1,Ht-Hs,Hs+Ht,(s-t)/s)
                                   ) 
  

}




#' Simulate time dependent fGn series
#' 
#' This function produces samples from a given time dependent fractional Gaussian noise process.
#' 
#' @param n The length of the simulated time series..
#' @param sigma The standard deviation of the innovations.
#' @param a Intercept in the evolution of the Hurst exponent.
#' @param b Slope in the evolution of the Hurst exponent.
#' @param Hs Numeric of length \code{n}. If evolution of Hurst exponent is 
#' to be given explicitly this is done here. Overrides \code{a} and \code{b}.
#' @return Returns the simulated time series as a \code{numeric} object.
#' 
#' @examples 
#' \donttest{
#' n = 200
#' sims = fgn_timedep_sim(n,sigma=1,a=0.6,b=0.3)
#' }
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords simulation ar1 timedep 
#' @export
#' @importFrom stats rnorm
fgn_timedep_sim <- function(n,sigma=1,a=0.6,b=0.3,Hs=NULL){
  # if(is.null(Hs)){
  #   Hs = a+b*seq(0,1,length.out=n)
  # }
  
  sigmat = sigmaHmaker(sigma,a,b,n)
  sigmachol = chol(sigmat)
  noise = sigmachol%*%rnorm(n)
  return(noise)
}



#' Default variables in events
#'
#' Sets the default variables in the list \code{events} used to specify the climatic
#' periods and separating events used in the linear predictor. The list contains the following arguments:
#' \itemize{
#'   \item{\code{num.threads} }{Integer describing the number of cores used by the INLA program. 
#'   For rgeneric models, stabiltiy is sometimes improved by setting this equal to \code{1} (default).}
#'   \item{\code{control.inla} }{List containing \code{h=0.01} and \code{restart=1}. 
#'   \code{h} denotes the step size. Changing this might help reach convergence. 
#'   \code{restart} is an integer indicating how many times INLA should be restart to 
#'   at the found optimum. This might help improve the accuracy of the optimization procedure.}
#'   \item{\code{control.family} }{List with settings to tell INLA to set the variance of the 
#'   Gaussian likelihood to be fixed and equal to \code{exp(-12)}.}
#' }
#' @return Returns a list including default values for all variables in \code{inla.options}.
#'
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords inla.ews inla options default
#'
inla.options.default <- function(){
  return(list(
    num.threads=1,
    control.mode=list(restart=TRUE),
    control.inla=list(h=0.01,restart=1),
    control.family = list(hyper = list(prec = list(initial = 12, fixed=TRUE)))
  )
  )
}

#' Import default arguments
#'
#' Fills out missing arguments in list \code{opt} with default arguments in list
#' \code{default.opt}.
#' @param opt List object with different specifications.
#' @param default.opt List of default variables corresponding to \code{opt}.
#'
#' @return Returns the \code{opt} list, but with values from \code{default.opt} inserted
#' in missing values.
#'
#' @author Eirik Myrvoll-Nilsen, \email{eirikmn91@gmail.com}
#' @seealso \code{\link{inla.ews}}
#' @keywords inla.ews default
set.options <- function(opt,default.opt){
  temp = default.opt
  
  if(length(opt)>0){
    for(i in 1:length(opt)){
      if(names(opt)[i] %in% names(default.opt)){
        if(!is.list(opt[[i]])){
          temp[[ names(opt)[i] ]] <- opt[[i]]
        }else{
          for(j in 1:length(opt[[i]])){
            temp[[ names(opt)[i] ]][[names(opt[[i]])[j]]] <- opt[[i]][[j]]
          }
        }
      }else{
        temp[[names(opt)[i]]] <- opt[[i]]
      }
    }
  }
  return(temp)
}
